<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/Article">
  
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  <title>Proxy Reference | Qordoba - Strings Intelligence Platform..</title>
  <meta name="description" content="Create a fully automated strings management solution">
  <meta name="author" content="Qordoba"/>
  <meta property="og:title" content="Strings Intelligence Platform.."/>
  <meta property="og:site_name" content="Qordoba"/>
  
  <link rel="icon" type="image/x-icon" href="/assets/images/favicon.png"/>
  <link rel="stylesheet" href="/assets/styles.css?v=1546646361"/>
</head>


  <body id="" >
    <header class="site-header">
  <div class="enterprise">
        <div class="container">
       <nav class="enterprise-sites one-half column">
         <ul>
           <li>
             <a href="https://qordoba.com/customers/" target="_blank">Customers</a>
           </li>
           <li>
             <a href="https://qordoba.com/partners/" target="_blank" >Partners</a>
           </li>
         </ul>
       </nav>   
      <nav class="enterprise-contact one-half column">
        <ul>
          <li>
            <a href="https://support.qordoba.com/" target="_blank">Support</a>
          </li>
          <li>
            <a href="http://go.qordoba.com/WF-Request-A-Demo__LP-DevDocs-Header.html">Request Demo</a>
          </li>
        </ul>
      </nav>
    </div>
  </div>
  <!-- .enterprise -->
  <div class="navbar">
    <div class="container">
      <a href="/" class="navbar-brand">
        <img src="/assets/images/qordoba-white-logo.png" alt="Qordoba" style="height: 35px;" >
      </a>
      <button data-toggle="collapse" data-target="#navbar" aria-expanded="true" aria-controls="navbar" class="navbar-toggle">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <nav id="navbar" class="navbar-nav">
        <ul>
          <li>
            <a href="/docs/" >Docs</a>
          </li>
          <li>
            <a href="/ecosystem" >Ecosystem</a>

          </li>
          <li>
            <a href="/security/" >Security</a>
          </li>
         
           <li>
            <a href="https://app.qordoba.com/docs/swagger-ui/index.html?url=/assets/swagger.json#!/routes/orgList">API</a>
          </li>
          <li>

            <a href="/install/" class="button button-dark" data-analytics='{"event": "Clicked download", "type": "button", "location": "header"}'>Installation</a>

          </li>
        </ul>
      </nav>
    </div>
  </div>
  <!-- .navbar -->
</header>


    <div class="page ">
  


  <div class="container">
    <div class="content">
      <h1 id="proxy-reference">Proxy Reference</h1>

<p>Qordoba listens for traffic on four ports, which by default are:</p>

<ul>
<li><code>:8000</code> on which Qordoba listens for incoming HTTP traffic from your clients,
and forwards it to your upstream services. <strong>This is the port that interests
us in this guide.</strong></li>
<li><code>:8443</code> on which Qordoba listens for incoming HTTPS traffic. This port has a
similar behavior as the <code>:8000</code> port, except that it expects HTTPS traffic
only. This port can be disabled via the configuration file.</li>
<li><code>:8001</code> on which the <a href="/docs//admin-api">Admin API</a> used to configure Qordoba listens.</li>
<li><code>:8444</code> on which the <a href="/docs//admin-api">Admin API</a> listens for HTTPS traffic.</li>
</ul>

<p>In this document we cover routing capabilities of Qordoba by explaining in detail
how incoming requests on port <code>:8000</code> are proxied to a configured upstream
service depending on their headers, URI, and HTTP method.</p>

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
<li><a href="#terminology">Terminology</a></li>
<li><a href="#overview">Overview</a></li>
<li><a href="#reminder-how-to-add-an-api-to-qordoba">Reminder: How to add an API to Qordoba</a></li>
<li><a href="#routing-capabilities">Routing capabilities</a>

<ul>
<li><a href="#request-host-header">Request Host header</a>

<ul>
<li><a href="#using-wildcard-hostnames">Using wildcard hostnames</a></li>
<li><a href="#the-preserve_host-property">The <code>preserve_host</code> property</a></li>
</ul></li>
<li><a href="#request-uri">Request URI</a>

<ul>
<li><a href="#using-regexes-in-uris">Using regexes in URIs</a>

<ul>
<li><a href="#evaluation-order">Evaluation order</a></li>
<li><a href="#capturing-groups">Capturing groups</a></li>
<li><a href="#escaping-special-characters">Escaping special characters</a></li>
</ul></li>
<li><a href="#the-strip_uri-property">The <code>strip_uri</code> property</a></li>
</ul></li>
<li><a href="#request-http-method">Request HTTP method</a></li>
</ul></li>
<li><a href="#routing-priorities">Routing priorities</a></li>
<li><a href="#proxying-behavior">Proxying behavior</a>

<ul>
<li><a href="#1-load-balancing">1. Load balancing</a></li>
<li><a href="#2-plugins-execution">2. Plugins execution</a></li>
<li><a href="#3-proxying-upstream-timeouts">3. Proxying &amp; upstream timeouts</a></li>
<li><a href="#4-errors-retries">4. Errors &amp; retries</a></li>
<li><a href="#5-response">5. Response</a></li>
</ul></li>
<li><a href="#configuring-a-fallback-api">Configuring a fallback API</a></li>
<li><a href="#configuring-ssl-for-an-api">Configuring SSL for an API</a>

<ul>
<li><a href="#the-https_only-property">The <code>https_only</code> property</a></li>
<li><a href="#the-http_if_terminated-property">The <code>http_if_terminated</code> property</a></li>
</ul></li>
<li><a href="#proxy-websocket-traffic">Proxy WebSocket traffic</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="terminology">Terminology</h2>

<ul>
<li><code>API</code>: This term refers to the API entity of Qordoba. You configure your APIs,
that point to your own upstream services, through the Admin API.</li>
<li><code>Plugin</code>: This refers to Qordoba &quot;plugins&quot;, which are pieces of business logic
that run in the proxying lifecycle. Plugins can be configured through the
Admin API - either globally (all incoming traffic) or on a per-API basis.</li>
<li><code>Client</code> or : Refers to the <em>downstream</em> client making requests to Qordoba&#39;s
proxy port.</li>
<li><code>Upstream service</code>: Refers to your own API/service sitting behind Qordoba, to
which client requests are forwarded.</li>
</ul>

<p><a href="#table-of-contents">Back to TOC</a></p>

<h2 id="overview">Overview</h2>

<p>From a high level perspective, Qordoba will listen for HTTP traffic on its
configured proxy port (<code>8000</code> by default), recognize which upstream service is
being requested, run the configured plugins for that API, and forward the HTTP
request upstream to your own API or service.</p>

<p>When a client makes a request to the proxy port, Qordoba will decide to which
upstream service or API to route (or forward) the incoming request, depending
on the API configuration in Qordoba, which is managed via the Admin API. You can
configure APIs with various properties, but the three relevant ones for routing
incoming traffic are <code>hosts</code>, <code>uris</code>, and <code>methods</code>.</p>

<p>If Qordoba cannot determine to which upstream API a given request should be
routed, Qordoba will respond with:</p>
<div class="highlight"><pre><code class="language-http" data-lang="http"><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">404</span> <span class="ne">Not Found</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">application/json</span>
<span class="na">Server</span><span class="p">:</span> <span class="s">qordoba/&lt;x.x.x&gt;</span>

<span class="p">{</span><span class="w">
    </span><span class="nt">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"no API found with those values"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p><a href="#table-of-contents">Back to TOC</a></p>

<h2 id="reminder-how-to-add-an-api-to-qordoba">Reminder: How to add an API to Qordoba</h2>

<p>The <a href="/docs//getting-started/adding-your-api">Adding your API</a> quickstart guide explains how Qordoba is
configured via Qordoba&#39;s <a href="/docs//admin-api">Admin API</a> running by default on port <code>8001</code>.
Adding an API to Qordoba is as easy as sending an HTTP request:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>curl -i -X POST http://localhost:8001/apis/ <span class="se">\</span>
    -d <span class="s1">'name=my-api'</span> <span class="se">\</span>
    -d <span class="s1">'upstream_url=http://my-api.com'</span> <span class="se">\</span>
    -d <span class="s1">'hosts=example.com'</span> <span class="se">\</span>
    -d <span class="s1">'uris=/my-api'</span> <span class="se">\</span>
    -d <span class="s1">'methods=GET,HEAD'</span>
HTTP/1.1 201 Created
...
</code></pre></div>
<p>This request instructs Qordoba to register an API named &quot;my-api&quot;, reachable at
&quot;<a href="http://my-api.com">http://my-api.com</a>&quot;. It also specifies various routing properties, though note
that <strong>only one of</strong> <code>hosts</code>, <code>uris</code> and <code>methods</code> is  required.</p>

<p>Adding such an API would mean that you configured Qordoba to proxy all incoming
requests matching the specified <code>hosts</code>, <code>uris</code>, and <code>methods</code> to
<code>http://example.com</code>. Qordoba is a transparent proxy, and it will forward the
request to your upstream service untouched, with the exception of the addition
of various headers such as <code>Connection</code>.</p>

<p><a href="#table-of-contents">Back to TOC</a></p>

<h2 id="routing-capabilities">Routing capabilities</h2>

<p>Let&#39;s now discuss how Qordoba matches a request to the configured <code>hosts</code>, <code>uris</code>
and <code>methods</code> properties (or fields) of your API. Note that all three of these
fields are <strong>optional</strong>, but at least <strong>one of them</strong> must be specified. For a
client request to match an API:</p>

<ul>
<li>The request <strong>must</strong> include <strong>all</strong> of the configured fields</li>
<li>The values of the fields in the request <strong>must</strong> match at least one of the
configured values (While the field configurations accepts one or more values,
a request needs only one of the values to be considered a match)</li>
</ul>

<p>Let&#39;s go through a few examples. Consider an API configured like this:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
    </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"my-api"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"upstream_url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://my-api.com"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"hosts"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"example.com"</span><span class="p">,</span><span class="w"> </span><span class="s2">"service.com"</span><span class="p">],</span><span class="w">
    </span><span class="nt">"uris"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"/foo"</span><span class="p">,</span><span class="w"> </span><span class="s2">"/bar"</span><span class="p">],</span><span class="w">
    </span><span class="nt">"methods"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"GET"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>Some of the possible requests matching this API could be:</p>
<div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/foo</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">example.com</span>
</code></pre></div><div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/bar</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">service.com</span>
</code></pre></div><div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/foo/hello/world</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">example.com</span>
</code></pre></div>
<p>All three of these requests satisfy all the conditions set in the API
definition.</p>

<p>However, the following requests would <strong>not</strong> match the configured conditions:</p>
<div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">example.com</span>
</code></pre></div><div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">POST</span> <span class="nn">/foo</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">example.com</span>
</code></pre></div><div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/foo</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">foo.com</span>
</code></pre></div>
<p>All three of these requests satisfy only two of configured conditions. The
first request&#39;s URI is not a match for any of the configured <code>uris</code>, same for
the second request&#39;s HTTP method, and the third request&#39;s Host header.</p>

<p>Now that we understand how the <code>hosts</code>, <code>uris</code>, and <code>methods</code> properties work
together, let&#39;s explore each property individually.</p>

<p><a href="#table-of-contents">Back to TOC</a></p>

<h3 id="request-host-header">Request Host header</h3>

<p>Routing a request based on its Host header is the most straightforward way to
proxy traffic through Qordoba, as this is the intended usage of the HTTP Host
header. Qordoba makes it easy to do so via the <code>hosts</code> field of the API entity.</p>

<p><code>hosts</code> accepts multiple values, which must be comma-separated when specifying
them via the Admin API:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>curl -i -X POST http://localhost:8001/apis/ <span class="se">\</span>
    -d <span class="s1">'name=my-api'</span> <span class="se">\</span>
    -d <span class="s1">'upstream_url=http://my-api.com'</span> <span class="se">\</span>
    -d <span class="s1">'hosts=my-api.com,example.com,service.com'</span>
HTTP/1.1 201 Created
...
</code></pre></div>
<p>To satisfy the <code>hosts</code> condition of this API, any incoming request from a
client must now have its Host header set to one of:</p>
<div class="highlight"><pre><code class="language-" data-lang="">Host: my-api.com
</code></pre></div>
<p>or:</p>
<div class="highlight"><pre><code class="language-" data-lang="">Host: example.com
</code></pre></div>
<p>or:</p>
<div class="highlight"><pre><code class="language-" data-lang="">Host: service.com
</code></pre></div>
<p><a href="#table-of-contents">Back to TOC</a></p>

<h4 id="using-wildcard-hostnames">Using wildcard hostnames</h4>

<p>To provide flexibility, Qordoba allows you to specify hostnames with wildcards in
the <code>hosts</code> field. Wildcard hostnames allow any matching Host header to satisfy
the condition, and thus match a given API.</p>

<p>Wildcard hostnames <strong>must</strong> contain <strong>only one</strong> asterisk at the leftmost
<strong>or</strong> rightmost label of the domain. Examples:</p>

<ul>
<li><code>*.example.com</code> would allow Host values such as <code>a.example.com</code> and
<code>x.y.example.com</code> to match.</li>
<li><code>example.*</code> would allow Host values such as <code>example.com</code> and <code>example.org</code>
to match.</li>
</ul>

<p>A complete example would look like this:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
    </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"my-api"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"upstream_url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://my-api.com"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"hosts"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"*.example.com"</span><span class="p">,</span><span class="w"> </span><span class="s2">"service.com"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>Which would allow the following requests to match this API:</p>
<div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">an.example.com</span>
</code></pre></div><div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">service.com</span>
</code></pre></div>
<p><a href="#table-of-contents">Back to TOC</a></p>

<h4 id="the-preserve_host-property">The <code>preserve_host</code> property</h4>

<p>When proxying, Qordoba&#39;s default behavior is to set the upstream request&#39;s Host
header to the hostname of the API&#39;s <code>upstream_url</code> property. The
<code>preserve_host</code> field accepts a boolean flag instructing Qordoba not to do so.</p>

<p>For example, when the <code>preserve_host</code> property is not changed and an API is
configured like this:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
    </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"my-api"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"upstream_url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://my-api.com"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"hosts"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"service.com"</span><span class="p">],</span><span class="w">
</span><span class="err">}</span><span class="w">
</span></code></pre></div>
<p>A possible request from a client to Qordoba could be:</p>
<div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">service.com</span>
</code></pre></div>
<p>Qordoba would extract the Host header value from the the hostname of the API&#39;s
<code>upstream_url</code> field, and would send the following request to your upstream
service:</p>
<div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">my-api.com</span>
</code></pre></div>
<p>However, by explicitly configuring your API with <code>preserve_host=true</code>:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
    </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"my-api"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"upstream_url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://my-api.com"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"hosts"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"service.com"</span><span class="p">],</span><span class="w">
    </span><span class="nt">"preserve_host"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>And assuming the same request from the client:</p>
<div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">service.com</span>
</code></pre></div>
<p>Qordoba would preserve the Host on the client request and would send the following
request to your upstream service:</p>
<div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">service.com</span>
</code></pre></div>
<p><a href="#table-of-contents">Back to TOC</a></p>

<h3 id="request-uri">Request URI</h3>

<p>Another way for Qordoba to route a request to a given upstream service is to
specify a request URI via the <code>uris</code> property. To satisfy this field&#39;s
condition, a client request&#39;s URI <strong>must</strong> be prefixed with one of the values
of the <code>uris</code> field.</p>

<p>For example, in an API configured like this:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
    </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"my-api"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"upstream_url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://my-api.com"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"uris"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"/service"</span><span class="p">,</span><span class="w"> </span><span class="s2">"/hello/world"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>The following requests would match the configured API:</p>
<div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/service</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">my-api.com</span>
</code></pre></div><div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/service/resource?param=value</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">my-api.com</span>
</code></pre></div><div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/hello/world/resource</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">anything.com</span>
</code></pre></div>
<p>For each of these requests, Qordoba detects that their URI is prefixed with one of
the API&#39;s <code>uris</code> values. By default, Qordoba would then forward the request
upstream with the untouched, <strong>same URI</strong>.</p>

<p>When proxying with URIs prefixes, <strong>the longest URIs get evaluated first</strong>.
This allow you to define two APIs with two URIs: <code>/service</code> and
<code>/service/resource</code>, and ensure that the former does not &quot;shadow&quot; the latter.</p>

<p><a href="#table-of-contents">Back to TOC</a></p>

<h4 id="using-regexes-in-uris">Using regexes in URIs</h4>

<p>Qordoba supports regular expression pattern matching for an API&#39;s <code>uris</code> field via
<a href="http://pcre.org/">PCRE</a> (Perl Compatible Regular Expression). You can assign
URIs as both prefixes and regexes to an API at the same time.</p>

<p>For example, if we consider the following API:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
    </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"regex-matching-api"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"upstream_url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://my-api.com"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"uris"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"/users/\d+/profile"</span><span class="p">,</span><span class="w"> </span><span class="s2">"/following"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>The following requests would match this API and be proxied by Qordoba:</p>
<div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/following</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">...</span>
</code></pre></div><div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/users/123/profile</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">...</span>
</code></pre></div>
<p>The provided regexes are evaluated with the <code>a</code> PCRE flag (<code>PCRE_ANCHORED</code>),
meaning that they will be constrained to match at the first matching point
in the URI (the root <code>/</code> character).</p>

<p><a href="#table-of-contents">Back to TOC</a></p>

<h5 id="evaluation-order">Evaluation order</h5>

<p>As previously mentioned, Qordoba evaluates prefix URIs by length: the longest
prefix URIs are evaluated first. However, Qordoba will evaluate regex URIs <strong>based
on the order in which they are defined</strong>. This means that considering the
following APIs:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"api-1"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"upstream_url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://my-api-1.com"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"uris"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"/status/\d+"</span><span class="p">]</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"api-2"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"upstream_url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://my-api-2.com"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"uris"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"/version/\d+/status/\d+"</span><span class="p">]</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"api-3"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"upstream_url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://my-api-3.com"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"uris"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"/version"</span><span class="p">]</span><span class="w">
    </span><span class="p">},</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div>
<p>In this scenario, Qordoba will evaluate incoming requests against the following
defined URIs, in this order:</p>

<ol>
<li><code>/version</code></li>
<li><code>/status/\d+</code></li>
<li><code>/version/\d+/status/\d+</code></li>
</ol>

<p>URI prefixes are always evaluated first. Then, <code>api-1</code> is defined before
<code>api-2</code>, and hence, sees its <code>uris</code> evaluated first.</p>

<p>As usual, a request must still match an API&#39;s <code>hosts</code> and <code>methods</code> properties
as well, and Qordoba will traverse your APIs until it finds one that matches
the most rules (see <a href="#routing-priorities">Routing priorities</a>).</p>

<p><a href="#table-of-contents">Back to TOC</a></p>

<h5 id="capturing-groups">Capturing groups</h5>

<p>Capturing groups are also supported, and the matched group will be extracted
from the URI and available for plugins consumption. If we consider the
following regex:</p>
<div class="highlight"><pre><code class="language-" data-lang="">/version/(?&lt;version&gt;\d+)/users/(?&lt;user&gt;\S+)
</code></pre></div>
<p>And the following request URI:</p>
<div class="highlight"><pre><code class="language-" data-lang="">/version/1/users/john
</code></pre></div>
<p>Qordoba will consider the request URI a match, and if the overall API is matched
(considering <code>hosts</code> and <code>methods</code> fields), the extracted capturing groups
will be available from the plugins in the <code>ngx.ctx</code> variable:</p>
<div class="highlight"><pre><code class="language-lua" data-lang="lua"><span class="kd">local</span> <span class="n">router_matches</span> <span class="o">=</span> <span class="n">ngx</span><span class="p">.</span><span class="n">ctx</span><span class="p">.</span><span class="n">router_matches</span>

<span class="c1">-- router_matches.uri_captures is:</span>
<span class="c1">-- { "1", "john", version = "1", user = "john" }</span>
</code></pre></div>
<p><a href="#table-of-contents">Back to TOC</a></p>

<h5 id="escaping-special-characters">Escaping special characters</h5>

<p>Next, it is worth noting that characters found in regexes are often
reserved characters according to
<a href="http://www.gbiv.com/protocols/uri/rfc/rfc3986.html">RFC 3986</a> and as such,
should be percent-encoded. <strong>When configuring APIs with regex URIs via the
Admin API, be sure to URL encode your payload if necessary</strong>. For example,
with <code>curl</code> and using an <code>application/x-www-form-urlencoded</code> MIME type:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>curl -i -X POST http://localhost:8001/apis <span class="se">\</span>
    --data <span class="s1">'name=my-api'</span> <span class="se">\</span>
    --data <span class="s1">'upstream_url=http://my-api.com'</span> <span class="se">\</span>
    --data-urlencode <span class="s1">'uris=/status/\d+'</span>
HTTP/1.1 201 Created
...
</code></pre></div>
<p>Note that <code>curl</code> does not automatically URL encode your payload, and note the
usage of <code>--data-urlencode</code>, which prevents the <code>+</code> character to be URL decoded
and interpreted as a space <code></code> by Qordoba&#39;s Admin API.</p>

<p>Last but not least - and still related to special characters commonly found in
PCRE sequences - we must consider the comma, which is used by Qordoba to delimit
several entries in the <code>uris</code> property. Because of this, commas used in a PCRE
sequence must be escaped, like so:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>curl -i -X POST http://localhost:8001/apis <span class="se">\</span>
    --data <span class="s1">'name=my-api'</span> <span class="se">\</span>
    --data <span class="s1">'upstream_url=http://my-api.com'</span> <span class="se">\</span>
    --data-urlencode <span class="s1">'uris=/status/\d+{1\,3},/version/\d+/status/\d+{1\,3}'</span>
HTTP/1.1 201 Created
...
</code></pre></div>
<p>In the above example, two regex URIs are defined, and both of these URIs
contain a repeated escape sequence: <code>\d+{1,3}</code>. Because those two URIs are
separated via a comma delimiter, we must escape any comma present in the
regexes themselves to ensure Qordoba&#39;s Admin API does not interpret them as a
separator.</p>

<p><a href="#table-of-contents">Back to TOC</a></p>

<h4 id="the-strip_uri-property">The <code>strip_uri</code> property</h4>

<p>It may be desirable to specify a URI prefix to match an API, but not
include it in the upstream request. To do so, use the <code>strip_uri</code> boolean
property by configuring an API like this:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
    </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"my-api"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"upstream_url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://my-api.com"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"uris"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"/service"</span><span class="p">],</span><span class="w">
    </span><span class="nt">"strip_uri"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>Enabling this flag instructs Qordoba that when proxying this API, it should
<strong>not</strong> include the matching URI prefix in the upstream request&#39;s URI. For
example, the following client&#39;s request to the API configured as above:</p>
<div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/service/path/to/resource</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="s">Host:</span>
</code></pre></div>
<p>Will cause Qordoba to send the following request to your upstream service:</p>
<div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/path/to/resource</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">my-api.com</span>
</code></pre></div>
<p>The same way, if a regex URI is defined on an API that has <code>strip_uri</code> enabled,
the entirety of the request URI matching sequence will be stripped. Example:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
    </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"my-regex-api"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"upstream_url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://my-api.com"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"uris"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"/version/\d+/service"</span><span class="p">],</span><span class="w">
    </span><span class="nt">"strip_uri"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>The following HTTP request matching the provided URI:</p>
<div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/version/1/service/path/to/resource</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">...</span>
</code></pre></div>
<p>Will be proxied upstream by Qordoba as:</p>
<div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/path/to/resource</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">my-api.com</span>
</code></pre></div>
<p><a href="#table-of-contents">Back to TOC</a></p>

<h3 id="request-http-method">Request HTTP method</h3>

<p>Starting with Qordoba 0.10, client requests can also be routed depending on their
HTTP method by specifying the <code>methods</code> field. By default, Qordoba will route a
request to an API regardless of its HTTP method. But when this field is set,
only requests with the specified HTTP methods will be matched.</p>

<p>This field also accepts multiple values. Here is an example of an API allowing
routing via <code>GET</code> and <code>HEAD</code> HTTP methods:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
    </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"api-1"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"upstream_url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://my-api.com"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"methods"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"GET"</span><span class="p">,</span><span class="w"> </span><span class="s2">"HEAD"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>Such an API would be matched with the following requests:</p>
<div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="s">Host:</span>
</code></pre></div><div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">HEAD</span> <span class="nn">/resource</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="s">Host:</span>
</code></pre></div>
<p>But would not match a <code>POST</code> or <code>DELETE</code> request. This allows for much more
granularity when configuring APIs and Plugins. For example, one could imagine
two APIs pointing to the same upstream service: one API allowing unlimited
unauthenticated <code>GET</code> requests, and a second API allowing only authenticated
and rate-limited <code>POST</code> requests (by applying the authentication and rate
limiting plugins to such requests).</p>

<p><a href="#table-of-contents">Back to TOC</a></p>

<h2 id="routing-priorities">Routing priorities</h2>

<p>An API may define matching rules based on its <code>hosts</code>, <code>uris</code>, and <code>methods</code>
fields. For Qordoba to match an incoming request to an API, all existing fields
must be satisfied. However, Qordoba allows for quite some flexibility by allowing
two or more APIs to be configured with fields containing the same values - when
this occurs, Qordoba applies a priority rule.</p>

<p>The rule is that : <strong>when evaluating a request, Qordoba will first try
to match the APIs with the most rules</strong>.</p>

<p>For example, two APIs are configured like this:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
    </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"api-1"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"upstream_url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://my-api.com"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"hosts"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"example.com"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="err">,</span><span class="w">
</span><span class="p">{</span><span class="w">
    </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"api-2"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"upstream_url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://my-api-2.com"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"hosts"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"example.com"</span><span class="p">],</span><span class="w">
    </span><span class="nt">"methods"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"POST"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>api-2 has a <code>hosts</code> field <strong>and</strong> a <code>methods</code> field, so it will be
evaluated first by Qordoba. By doing so, we avoid api-1 &quot;shadowing&quot; calls
intended for api-2.</p>

<p>Thus, this request will match api-1:</p>
<div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">example.com</span>
</code></pre></div>
<p>And this request will match api-2:</p>
<div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">POST</span> <span class="nn">/</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">example.com</span>
</code></pre></div>
<p>Following this logic, if a third API was to be configured with a <code>hosts</code> field,
a <code>methods</code> field, and a <code>uris</code> field, it would be evaluated first by Qordoba.</p>

<p><a href="#table-of-contents">Back to TOC</a></p>

<h2 id="proxying-behavior">Proxying behavior</h2>

<p>The proxying rules above detail how Qordoba forwards incoming requests to your
upstream services. Below we detail what happens internally between the time
Qordoba <em>recognizes</em> an HTTP request to a target service, and the actual
<em>forwarding</em> of the request upstream.</p>

<p><a href="#table-of-contents">Back to TOC</a></p>

<h3 id="1-load-balancing">1. Load balancing</h3>

<p>Starting with Qordoba 0.10, Qordoba implements load balancing capabilities to
distribute the forwarded requests across multiple instances of an upstream
service.</p>

<p>Previous to Qordoba 0.10, Ordinarily, Qordoba would send proxied requests to the
<code>upstream_url</code>, and load balancing across multiple upstream instances required
an external load balancer.</p>

<p>You can find more informations about adding load balancing to your APIs by
consulting the <a href="/docs//loadbalancing">Load Balancing Reference</a>.</p>

<p><a href="#table-of-contents">Back to TOC</a></p>

<h3 id="2-plugins-execution">2. Plugins execution</h3>

<p>Qordoba is extensible via &quot;plugins&quot; that hook themselves in the
request/response lifecycle of the proxied requests. Plugins can perform a
variety of operations in your environment and/or transformations on the proxied
request.</p>

<p>Plugins can be configured to run globally (for all proxied traffic) or on a
per-API basis by creating a <a href="/docs//admin-api#plugin-object">plugin configuration</a>
through the Admin API.</p>

<p>When a plugin is configured for a given API, and the API has been matched from
an incoming request, Qordoba will execute the configured plugin(s) for this
request before proxying it to your upstream service. This includes, among
others, the <code>access</code> phase of the plugin, on which you can find more
informations about in the <a href="/docs//plugin-development">Plugin development guide</a>.</p>

<p><a href="#table-of-contents">Back to TOC</a></p>

<h3 id="3-proxying-upstream-timeouts">3. Proxying &amp; upstream timeouts</h3>

<p>Once Qordoba has executed all the necessary logic (including plugins), it is ready
to forward the request to your upstream service. This is done via Nginx&#39;s
<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html">ngx_http_proxy_module</a>. Since Qordoba <code>0.10</code>, the timeout
duration for the connections between Qordoba and your upstream services may be
configured via these three properties of the API object:</p>

<ul>
<li><code>upstream_connect_timeout</code>: defines in milliseconds the timeout for
establishing a connection to your upstream service. Defaults to <code>60000</code>.</li>
<li><code>upstream_send_timeout</code>: defines in milliseconds a timeout between two
successive write operations for transmitting a request to your upstream
service.  Defaults to <code>60000</code>.</li>
<li><code>upstream_read_timeout</code>: defines in milliseconds a timeout between two
successive read operations for receiving a request from your upstream
service.  Defaults to <code>60000</code>.</li>
</ul>

<p>Qordoba will send the request over HTTP/1.1, and set the following headers:</p>

<ul>
<li><code>Host: &lt;your_upstream_host&gt;</code>, as previously described in this document.</li>
<li><code>Connection: keep-alive</code>, to allow for reusing the upstream connections.</li>
<li><code>X-Real-IP: &lt;remote_addr&gt;</code>, where <code>$remote_addr</code> is the variable bearing
the same name provided by
<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#var_remote_addr">ngx_http_core_module</a>. Please note that the
<code>$remote_addr</code> is likely overridden by
<a href="http://nginx.org/en/docs/http/ngx_http_realip_module.html">ngx_http_realip_module</a>.</li>
<li><code>X-Forwarded-For: &lt;address&gt;</code>, where <code>&lt;address&gt;</code> is the content of
<code>$realip_remote_addr</code> provided by
<a href="http://nginx.org/en/docs/http/ngx_http_realip_module.html">ngx_http_realip_module</a> appended to the request
header with the same name.</li>
<li><code>X-Forwarded-Proto: &lt;protocol&gt;</code>, where <code>&lt;protocol&gt;</code> is the protocol used by
the client. In the case where <code>$realip_remote_addr</code> is one of the <strong>trusted</strong>
addresses, the request header with the same name gets forwarded if provided.
Otherwise, the value of the <code>$scheme</code> variable provided by
<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#var_scheme">ngx_http_core_module</a> will be used.</li>
<li><code>X-Forwarded-Host: &lt;host&gt;</code>, where <code>&lt;host&gt;</code> is the host name sent by
the client. In the case where <code>$realip_remote_addr</code> is one of the <strong>trusted</strong>
addresses, the request header with the same name gets forwarded if provided.
Otherwise, the value of the <code>$host</code> variable provided by
<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#var_host">ngx_http_core_module</a> will be used.</li>
<li><code>X-Forwarded-Port: &lt;port&gt;</code>, where <code>&lt;port&gt;</code> is the port of the server which
accepted a request. In the case where <code>$realip_remote_addr</code> is one of the
<strong>trusted</strong> addresses, the request header with the same name gets forwarded
if provided. Otherwise, the value of the <code>$server_port</code> variable provided by
<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#var_server_port">ngx_http_core_module</a> will be used.</li>
</ul>

<p>All the other request headers are forwarded as-is by Qordoba.</p>

<p>One exception to this is made when using the WebSocket protocol. If so, Qordoba
will set the following headers to allow for upgrading the protocol between the
client and your upstream services:</p>

<ul>
<li><code>Connection: Upgrade</code></li>
<li><code>Upgrade: websocket</code></li>
</ul>

<p>More information on this topic is covered in the
<a href="#proxy-websocket-traffic">Proxy WebSocket traffic</a> section.</p>

<p><a href="#table-of-contents">Back to TOC</a></p>

<h3 id="4-errors-retries">4. Errors &amp; retries</h3>

<p>Whenever an error occurs during proxying, Qordoba will use the underlying
Nginx <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream_tries">retries</a> mechanism to pass the request on to
the next upstream.</p>

<p>There are two configurable elements here:</p>

<ol>
<li><p>The number of retries: this can be configured per API using the <code>retries</code>
property of the <code>API</code> object. See the <a href="/docs//admin-api">management API</a> for more
details on this.</p></li>
<li><p>What exactly constitutes an error: here Qordoba uses the Nginx defaults, which
means an error or timeout occuring while establishing a connection with the
server, passing a request to it, or reading the response header.</p></li>
</ol>

<p>The second option is based on Nginx&#39;s
[proxy_next_upstream][proxy_next_upstream] directive. This option is not
directly configurable through Qordoba, but can be added using a custom Nginx
configuration. See the <a href="/docs//configuration-reference">configuration reference</a> for
more details.</p>

<p><a href="#table-of-contents">Back to TOC</a></p>

<h3 id="5-response">5. Response</h3>

<p>Qordoba receives the response from the upstream service and send it back to the
downstream client in a streaming fashion. At this point Qordoba will execute
subsequent plugins added to that particular API that implement a hook in the
<code>header_filter</code> phase.</p>

<p>Once the <code>header_filter</code> phase of all registered plugins has been executed, the
following headers will be added by Qordoba and the full set of headers be sent to
the client:</p>

<ul>
<li><code>Via: qordoba/x.x.x</code>, where <code>x.x.x</code> is the Qordoba version in use</li>
<li><code>Qordoba-Proxy-Latency: &lt;latency&gt;</code>, where <code>latency</code> is the time in milliseconds
between Qordoba receiving the request from the client and sending the request to
your upstream service.</li>
<li><code>Qordoba-Upstream-Latency: &lt;latency&gt;</code>, where <code>latency</code> is the time in
milliseconds that Qordoba was waiting for the first byte of the upstream service
response.</li>
</ul>

<p>Once the headers are sent to the client, Qordoba will start executing
registered plugins for that API that implement the <code>body_filter</code> hook. This
hook may be called multiple times, due to the streaming nature of Nginx itself.
Each chunk of the upstream response that is successfully processed by such
<code>body_filter</code> hooks is sent back to the client. You can find more informations
about the <code>body_filter</code> hook in the <a href="/docs//plugin-development">Plugin development
guide</a>.</p>

<p><a href="#table-of-contents">Back to TOC</a></p>

<h2 id="configuring-a-fallback-api">Configuring a fallback API</h2>

<p>As a practical use-case and example of the flexibility offered by Qordoba&#39;s
proxying capabilities, let&#39;s try to implement a &quot;fallback API&quot;, so that in
order to avoid Qordoba responding with an HTTP <code>404</code>, &quot;API not found&quot;, we can
catch such requests and proxy them to a special upstream service of yours, or
apply a plugin to it (such a plugin could, for example, terminate the request
with a different status code or response without proxying the request).</p>

<p>Here is an example of such a fallback API:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
    </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"root-fallback"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"upstream_url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://dummy.com"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"uris"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"/"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>As you can guess, any HTTP request made to Qordoba would actually match this API,
since all URIs are prefixed by the root character <code>/</code>. As we know from the
<a href="#request-uri">Request URI</a> section, the longest URIs are evaluated first
by Qordoba, so the <code>/</code> URI will eventually be evaluated last by Qordoba, and
effectively provide a &quot;fallback&quot; API, only matched as a last resort.</p>

<p><a href="#table-of-contents">Back to TOC</a></p>

<h2 id="configuring-ssl-for-an-api">Configuring SSL for an API</h2>

<p>Qordoba provides a way to dynamically serve SSL certificates on a per-connection
basis. Starting with 0.10, the SSL plugin has been removed and SSL certificates
are directly handled by the core, and configurable via the Admin API. Your
client HTTP library must support the <a href="https://en.wikipedia.org/wiki/Server_Name_Indication">Server Name Indication</a> extension to
make use of this feature.</p>

<p>SSL certificates are handled by two resources of the Qordoba Admin API:</p>

<ul>
<li><code>/certificates</code>, which stores your keys and certificates.</li>
<li><code>/snis</code>, which associates a registered certificate with a Server Name
Indication.</li>
</ul>

<p>You can find the documentation for those two resources in the
<a href="/docs//admin-api">Admin API Reference</a>.</p>

<p>Here is how to configure an SSL certificate for a given API: first, upload your
SSL certificate and key via the Admin API:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>curl -i -X POST http://localhost:8001/certificates <span class="se">\</span>
    -F <span class="s2">"cert=@/path/to/cert.pem"</span> <span class="se">\</span>
    -F <span class="s2">"key=@/path/to/cert.key"</span> <span class="se">\</span>
    -F <span class="s2">"snis=ssl-example.com,other-ssl-example.com"</span>
HTTP/1.1 201 Created
...
</code></pre></div>
<p>The <code>snis</code> form parameter is a sugar parameter, directly inserting an SNI and
associating the uploaded certificate to it.</p>

<p>You must now register the following API within Qordoba. We&#39;ll route requests to
this API using the Host header for convenience:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>curl -i -X POST http://localhost:8001/apis <span class="se">\</span>
    -d <span class="s2">"name=ssl-api"</span> <span class="se">\</span>
    -d <span class="s2">"upstream_url=http://my-api.com"</span> <span class="se">\</span>
    -d <span class="s2">"hosts=ssl-example.com,other-ssl-example.com"</span>
HTTP/1.1 201 Created
...
</code></pre></div>
<p>You can now expect the API to be served over HTTPs by Qordoba:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>curl -i https://localhost:8443/ <span class="se">\</span>
  -H <span class="s2">"Host: ssl-example.com"</span>
HTTP/1.1 200 OK
...
</code></pre></div>
<p><a href="#table-of-contents">Back to TOC</a></p>

<h3 id="the-https_only-property">The <code>https_only</code> property</h3>

<p>If you wish an API to only be served through HTTPS, you can do so by enabling
its <code>https_only</code> property:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>curl -i -X POST http://localhost:8001/apis <span class="se">\</span>
    -d <span class="s2">"name=ssl-only-api"</span> <span class="se">\</span>
    -d <span class="s2">"upstream_url=http://example.com"</span> <span class="se">\</span>
    -d <span class="s2">"hosts=my-api.com"</span> <span class="se">\</span>
    -d <span class="s2">"https_only=true"</span>
HTTP/1.1 201 Created
...
</code></pre></div>
<p>By configuring your API like so, Qordoba will refuse to proxy traffic for it
without HTTPS. A request to Qordoba over plain HTTP targetting this API would
instruct your clients to upgrade to HTTPS:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>curl -i http://localhost:8000 <span class="se">\</span>
    -H <span class="s2">"Host: my-api.com"</span>
HTTP/1.1 426
Content-Type: application/json; <span class="nv">charset</span><span class="o">=</span>utf-8
Transfer-Encoding: chunked
Connection: Upgrade
Upgrade: TLS/1.2, HTTP/1.1
Server: qordoba/x.x.x

<span class="o">{</span><span class="s2">"message"</span>:<span class="s2">"Please use HTTPS protocol"</span><span class="o">}</span>
</code></pre></div>
<p><a href="#table-of-contents">Back to TOC</a></p>

<h3 id="the-http_if_terminated-property">The <code>http_if_terminated</code> property</h3>

<p>If you wish to consider the <code>X-Forwarded-Proto</code> header of your requests when
enforcing HTTPS only traffic, enable the <code>http_if_terminated</code> property of your
API definition.</p>

<p>Following the previous example, if we update our HTTPS-only API:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>curl -i -X PATCH http://localhost:8001/apis/ssl-only-api <span class="se">\</span>
    -d <span class="s2">"http_if_terminated=true"</span>
HTTP/1.1 200 OK
...
</code></pre></div>
<p>And we make a request with the <code>X-Forwarded-Proto</code> header (assuming it is
coming from a <strong>trusted</strong> client):</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>curl -i http://localhost:8000 <span class="se">\</span>
    -H <span class="s2">"Host: my-api.com"</span> <span class="se">\</span>
    -H <span class="s2">"X-Forwarded-Proto: https"</span>
HTTP/1.1 200 OK
...
</code></pre></div>
<p>Qordoba now proxies this request, because it assumes SSL termination has been
achieved by a previous component of your architecture.</p>

<p><a href="#table-of-contents">Back to TOC</a></p>

<h2 id="proxy-websocket-traffic">Proxy WebSocket traffic</h2>

<p>Qordoba supports WebSocket traffic thanks to the underlying Nginx implementation.
When you wish to establish a WebSocket connection between a client and your
upstream services <em>through</em> Qordoba, you must establish a WebSocket handshake.
This is done via the HTTP Upgrade mechanism. This is what your client request
made to Qordoba would look like:</p>
<div class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">Upgrade</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">my-websocket-api.com</span>
<span class="na">Upgrade</span><span class="p">:</span> <span class="s">WebSocket</span>
</code></pre></div>
<p>This will make Qordoba forward the <code>Connection</code> and <code>Upgrade</code> headers to your
upstream service, instead of dismissing them due to the hop-by-hop nature of a
standard HTTP proxy.</p>

<p><a href="#table-of-contents">Back to TOC</a></p>

<h2 id="conclusion">Conclusion</h2>

<p>Through this guide, we hope you gained knowledge of the underlying proxying
mechanism of Qordoba, from how is a request matched to an API, to how to allow for
using the WebSocket protocol or setup SSL for an API.</p>

<p>This website is Open-Source and can be found at
<a href="https://github.com/Mashape/getkong.org/">github.com/Mashape/getkong.org</a>.
Feel free to provide feedback to this document there, or propose improvements!</p>

<p>If not already done, we suggest that you also read the
<a href="/docs//loadbalancing">Load balancing Reference</a>, as it closely relates to the
topic we just covered.</p>

<p><a href="#table-of-contents">Back to TOC</a></p>

    </div>
  </div>
</div>


    
  <!-- section class="section subscribe-section" id="newsletter">
  <div class="container">
    <header class="section-header">
      <h4>Keep up with the latest features</h4>
    </header>

    <div class="row">
      <div class="one-half column offset-by-three">

      </div>
    </div>
  </div>
</section -->


<footer class="marketing-footer--light-gray">
  <section>
    <ul>
      <li class="logo-wrapper">
        <div class="logo">
          <img src="/assets/images/qordobalogoblue.png" alt="Qordoba" >
        </div>
      </li>
      <li>
        <nav>
          <h4>Use Cases</h4>
          <ul>
            <li><a href="#">Strings Management</a></li>
            <li><a href="#">Content AI</a></li>
            <li><a href="#">Localization</a></li>
            <li><a href="#">Persona Based Content</a></li>

          </ul>
        </nav>
      </li>
      <li>
        <nav>
          <h4>Support</h4>
          <ul>
            <li><a href="https://support.qordoba.com/">Knowledge Base</a></li>
            <li><a href="https://dev.qordoba.com/glossary/">Glossary of Qordoba Terms</a></li>
            <li><a href="https://www.youtube.com/channel/UC_ZMLcfNI1XQnV8frpeFsgA">Webinars</a></li>
            <li><a href="https://www.youtube.com/channel/UC_ZMLcfNI1XQnV8frpeFsgA">Tutorials</a></li>
          </ul>
        </nav>
      </li>
      <li>
        <nav>
          <h4>Network Status</h4>
          <ul>
            <li><a href="https://status.qordoba.com/">APIs</a></li>
            <li><a href="https://status.qordoba.com/">SmartSuggest</a></li>
            <li><a href="https://status.qordoba.com/">Emotion and Tone</a></li>
          </ul>
        </nav>
      </li>
      <li>
        <nav>
          <h4>Legal</h4>
          <ul>
            <li><a href="#">Terms of Service</a></li>
            <li><a href="#">Privacy Policy</a></li>
          </ul>
        </nav>
      </li>
    </ul>
  </section>

  <section class="legal">
    <ul>
      <li>
        <span class="mashape-footer-content">&copy; Qordoba. 2019</span>
      </li>
      <li>
        <div class="social-link">
          <a href="https://github.com/Qordobacode" title="Github"><i aria-label="Github" class="fa fa-github" aria-hidden="true"></i></a></div>
        <div class="social-link">
          <a href="https://twitter.com/qordoba" title="Twitter"><i aria-label="Twitter" class="fa fa-twitter" aria-hidden="true"></i></a>
        </div>
      </li>
    </ul>
  </section>
</footer>

    <script>
  var anchorForId = function (id) {
    var anchor = document.createElement("a");
    anchor.className = "header-link";
    anchor.href      = "#" + id;
    anchor.innerHTML = "<span class=\"sr-only\">Permalink</span><i class=\"fa fa-link\"></i>";
    anchor.title = "Permalink";
    return anchor;
  };
  var linkifyAnchors = function (level, containingElement) {
    var headers = containingElement.getElementsByTagName("h" + level);
    for (var h = 0; h < headers.length; h++) {
      var header = headers[h];
      if (typeof header.id !== "undefined" && header.id !== "") {
        header.prepend(anchorForId(header.id));
      }
    }
  };
  document.onreadystatechange = function () {
    if (this.readyState === "complete") {
      console.log("here")
      var contentBlock = document.getElementById("documentation");
      if (!contentBlock) {
        return;
      }
      for (var level = 1; level <= 6; level++) {
        linkifyAnchors(level, contentBlock);
      }
    }
  };
</script>


    <script src="/assets/app.js?v=1546646361"></script>

    <div id="fb-root"></div>

    <script id="github-bjs" src="https://buttons.github.io/buttons.js" async defer></script>
    <script id="twitter-wjs" type="text/javascript" src="https://platform.twitter.com/widgets.js" async defer></script>
    <script id="facebook-jssdk" type="text/javascript" src="https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.3&appId=842731852424506" async defer></script>

    <script type="text/javascript">
      piAId = '393112';
      piCId = '48375';

      (function() {
        function async_load(){
          var s = document.createElement('script'); s.type = 'text/javascript';
          s.src = ('https:' == document.location.protocol ? 'https://pi' : 'http://cdn') + '.pardot.com/pd.js';
          var c = document.getElementsByTagName('script')[0]; c.parentNode.insertBefore(s, c);
        }
        if(window.attachEvent) { window.attachEvent('onload', async_load); }
        else { window.addEventListener('load', async_load, false); }
      })();
    </script>

    <script type='text/javascript'>
      var _vwo_code=(function(){
      var account_id=125292,
      settings_tolerance=2000,
      library_tolerance=2500,
      use_existing_jquery=true,
      // DO NOT EDIT BELOW THIS LINE
      f=false,d=document;return{use_existing_jquery:function(){return use_existing_jquery;},library_tolerance:function(){return library_tolerance;},finish:function(){if(!f){f=true;var a=d.getElementById('_vis_opt_path_hides');if(a)a.parentNode.removeChild(a);}},finished:function(){return f;},load:function(a){var b=d.createElement('script');b.src=a;b.type='text/javascript';b.innerText;b.onerror=function(){_vwo_code.finish();};d.getElementsByTagName('head')[0].appendChild(b);},init:function(){settings_timer=setTimeout('_vwo_code.finish()',settings_tolerance);this.load('//dev.visualwebsiteoptimizer.com/j.php?a='+account_id+'&u='+encodeURIComponent(d.URL)+'&r='+Math.random());var a=d.createElement('style'),b='',h=d.getElementsByTagName('head')[0];a.setAttribute('id','_vis_opt_path_hides');a.setAttribute('type','text/css');if(a.styleSheet)a.styleSheet.cssText=b;else a.appendChild(d.createTextNode(b));h.appendChild(a);return settings_timer;}};}());_vwo_settings_timer=_vwo_code.init();
    </script>

    <script type="text/javascript">
      !function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","group","track","ready","alias","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="3.0.1";
        analytics.load("WDj0nSS7hpyxwL3evgbOzK755s0NUye6");
        analytics.page()
      }}();
    </script>

    <script type="text/javascript" src="//mashape.github.io/notification-bar/embed.js" async defer></script>
  </body>
</html>
